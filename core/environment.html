<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Environment &mdash; Elemental 0.82-dev documentation</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.82-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Elemental 0.82-dev documentation" href="../index.html" />
    <link rel="up" title="Core functionality" href="../core.html" />
    <link rel="next" title="The Matrix class" href="matrix.html" />
    <link rel="prev" title="libFLAME" href="imports/flame.html" /> 
  </head>
  <body>
      <div class="header"><img class="rightlogo" src="../_static/elemental-half.png" alt="Logo"/><h1 class="heading"><a href="../index.html">
          <span>Elemental 0.82-dev documentation</span></a></h1>
        <h2 class="heading"><span>Environment</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="imports/flame.html">libFLAME</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="matrix.html">The Matrix class</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="environment">
<h1>Environment<a class="headerlink" href="#environment" title="Permalink to this headline">¶</a></h1>
<p>This section describes the routines and data structures which help set up
Elemental&#8217;s programming environment: it discusses initialization of Elemental,
call stack manipulation, a custom data structure for complex data, many routines
for manipulating real and complex data, a litany of custom enums, and a few
useful routines for simplifying index calculations.</p>
<div class="section" id="build-and-version-information">
<h2>Build and version information<a class="headerlink" href="#build-and-version-information" title="Permalink to this headline">¶</a></h2>
<p>Every Elemental driver with proper command-line argument processing will run
<cite>PrintVersion</cite> if the <tt class="docutils literal"><span class="pre">--version</span></tt> argument is used. If <tt class="docutils literal"><span class="pre">--build</span></tt> is used,
then all of the below information is reported.</p>
<dl class="function">
<dt id="PrintVersion__osR">
void <tt class="descname">PrintVersion</tt><big>(</big>std::ostream&amp; <em>os</em><em>=std::cout </em><big>)</big><a class="headerlink" href="#PrintVersion__osR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the Git revision, (pre-)release version, and build type.
For example:</p>
<div class="highlight-python"><pre>Elemental version information:
  Git revision: 3c6fbdaad901a554fc27a83378d63dab55af0dd3
  Version:      0.81-dev
  Build type:   PureDebug</pre>
</div>
</dd></dl>

<dl class="function">
<dt id="PrintConfig__osR">
void <tt class="descname">PrintConfig</tt><big>(</big>std::ostream&amp; <em>os</em><em>=std::cout </em><big>)</big><a class="headerlink" href="#PrintConfig__osR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the relevant configuration details. For example:</p>
<div class="highlight-python"><pre>Elemental configuration:
  Math libraries: /usr/lib/liblapack.so;/usr/lib/libblas.so
  HAVE_F90_INTERFACE
  HAVE_PMRRR
  HAVE_MPI_REDUCE_SCATTER_BLOCK
  HAVE_MPI_IN_PLACE
  USE_BYTE_ALLGATHERS</pre>
</div>
</dd></dl>

<dl class="function">
<dt id="PrintCCompilerInfo__osR">
void <tt class="descname">PrintCCompilerInfo</tt><big>(</big>std::ostream&amp; <em>os</em><em>=std::cout </em><big>)</big><a class="headerlink" href="#PrintCCompilerInfo__osR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the relevant C compilation information. For example:</p>
<div class="highlight-python"><pre>Elemental's C compiler info:
  CMAKE_C_COMPILER:    /usr/local/bin/gcc
  MPI_C_COMPILER:      /home/poulson/Install/bin/mpicc
  MPI_C_INCLUDE_PATH:  /home/poulson/Install/include
  MPI_C_COMPILE_FLAGS:
  MPI_C_LINK_FLAGS:     -Wl,-rpath  -Wl,/home/poulson/Install/lib
  MPI_C_LIBRARIES:     /home/poulson/Install/lib/libmpich.so;/home/poulson/Install/lib/libopa.so;/home/poulson/Install/lib/libmpl.so;/usr/lib/i386-linux-gnu/librt.so;/usr/lib/i386-linux-gnu/libpthread.so</pre>
</div>
</dd></dl>

<dl class="function">
<dt id="PrintCxxCompilerInfo__osR">
void <tt class="descname">PrintCxxCompilerInfo</tt><big>(</big>std::ostream&amp; <em>os</em><em>=std::cout </em><big>)</big><a class="headerlink" href="#PrintCxxCompilerInfo__osR" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the relevant C++ compilation information. For example:</p>
<div class="highlight-python"><pre>Elemental's C++ compiler info:
  CMAKE_CXX_COMPILER:    /usr/local/bin/g++
  CXX_FLAGS:             -Wall
  MPI_CXX_COMPILER:      /home/poulson/Install/bin/mpicxx
  MPI_CXX_INCLUDE_PATH:  /home/poulson/Install/include
  MPI_CXX_COMPILE_FLAGS:
  MPI_CXX_LINK_FLAGS:     -Wl,-rpath  -Wl,/home/poulson/Install/lib
  MPI_CXX_LIBRARIES:     /home/poulson/Install/lib/libmpichcxx.so;/home/poulson/Install/lib/libmpich.so;/home/poulson/Install/lib/libopa.so;/home/poulson/Install/lib/libmpl.so;/usr/lib/i386-linux-gnu/librt.so;/usr/lib/i386-linux-gnu/libpthread.so</pre>
</div>
</dd></dl>

</div>
<div class="section" id="set-up-and-clean-up">
<h2>Set up and clean up<a class="headerlink" href="#set-up-and-clean-up" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Initialize__iR.cPPR">
void <tt class="descname">Initialize</tt><big>(</big>int&amp; <em>argc</em>, char**&amp; <em>argv</em><big>)</big><a class="headerlink" href="#Initialize__iR.cPPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes Elemental and (if necessary) MPI. The usage is very similar to
<tt class="docutils literal"><span class="pre">MPI_Init</span></tt>, but the <cite>argc</cite> and <cite>argv</cite> can be directly passed in.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;elemental.hpp&quot;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">elem</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">elem</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Finalize">
void <tt class="descname">Finalize</tt><big>(</big><big>)</big><a class="headerlink" href="#Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees all resources allocated by Elemental and (if necessary) MPI.</p>
</dd></dl>

<dl class="function">
<dt id="Initialized">
bool <tt class="descname">Initialized</tt><big>(</big><big>)</big><a class="headerlink" href="#Initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether or not Elemental is currently initialized.</p>
</dd></dl>

<dl class="function">
<dt id="ReportException__std::exceptionR">
void <tt class="descname">ReportException</tt><big>(</big>std::exception&amp; <em>e</em><big>)</big><a class="headerlink" href="#ReportException__std::exceptionR" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for handling Elemental&#8217;s various exceptions, e.g.,</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;elemental.hpp&quot;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">elem</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">);</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span> <span class="p">{</span> <span class="n">ReportException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">elem</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="blocksize-manipulation">
<h2>Blocksize manipulation<a class="headerlink" href="#blocksize-manipulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Blocksize">
int <tt class="descname">Blocksize</tt><big>(</big><big>)</big><a class="headerlink" href="#Blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the currently chosen algorithmic blocksize. The optimal value
depends on the problem size, algorithm, and architecture; the default value
is 128.</p>
</dd></dl>

<dl class="function">
<dt id="SetBlocksize__i">
void <tt class="descname">SetBlocksize</tt><big>(</big>int <em>blocksize</em><big>)</big><a class="headerlink" href="#SetBlocksize__i" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the algorithmic blocksize to the specified value.</p>
</dd></dl>

<dl class="function">
<dt id="PushBlocksizeStack__i">
void <tt class="descname">PushBlocksizeStack</tt><big>(</big>int <em>blocksize</em><big>)</big><a class="headerlink" href="#PushBlocksizeStack__i" title="Permalink to this definition">¶</a></dt>
<dd><p>It is frequently useful to temporarily change the algorithmic blocksize, so
rather than having to manually store and reset the current state, one can
simply push a new value onto a stack
(and later pop the stack to reset the value).</p>
</dd></dl>

<dl class="function">
<dt id="PopBlocksizeStack">
void <tt class="descname">PopBlocksizeStack</tt><big>(</big><big>)</big><a class="headerlink" href="#PopBlocksizeStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pops the stack of blocksizes. See above.</p>
</dd></dl>

</div>
<div class="section" id="default-process-grid">
<h2>Default process grid<a class="headerlink" href="#default-process-grid" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="DefaultGrid">
<a class="reference internal" href="grid.html#Grid__class" title="Grid">Grid&amp;</a> <tt class="descname">DefaultGrid</tt><big>(</big><big>)</big><a class="headerlink" href="#DefaultGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a process grid built over <tt class="xref cpp cpp-type docutils literal"><span class="pre">mpi::COMM_WORLD</span></tt>. This is
typically used as a means of allowing instances of the
<a class="reference internal" href="dist_matrix.html#DistMatrix:T.MC.MR:__class" title="DistMatrix&lt;T, MC, MR&gt;"><tt class="xref cpp cpp-type docutils literal"><span class="pre">DistMatrix&lt;T,MC,MR&gt;</span></tt></a> class to be constructed without having to
manually specify a process grid, e.g.,</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Build a 10 x 10 distributed matrix over mpi::COMM_WORLD</span>
<span class="n">elem</span><span class="o">::</span><span class="n">DistMatrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">MC</span><span class="p">,</span><span class="n">MR</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="call-stack-manipulation">
<h2>Call stack manipulation<a class="headerlink" href="#call-stack-manipulation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following call stack manipulation routines are only available in
non-release builds (i.e., PureDebug and HybridDebug) and are meant to allow
for the call stack to be printed (via <a class="reference internal" href="#DumpCallStack" title="DumpCallStack"><tt class="xref cpp cpp-func docutils literal"><span class="pre">DumpCallStack()</span></tt></a>) when an
exception is caught.</p>
</div>
<dl class="function">
<dt id="PushCallStack__ss">
void <tt class="descname">PushCallStack</tt><big>(</big>std::string <em>s</em><big>)</big><a class="headerlink" href="#PushCallStack__ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Push the given routine name onto the call stack.</p>
</dd></dl>

<dl class="function">
<dt id="PopCallStack">
void <tt class="descname">PopCallStack</tt><big>(</big><big>)</big><a class="headerlink" href="#PopCallStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the routine name at the top of the call stack.</p>
</dd></dl>

<dl class="function">
<dt id="DumpCallStack">
void <tt class="descname">DumpCallStack</tt><big>(</big><big>)</big><a class="headerlink" href="#DumpCallStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Print (and empty) the contents of the call stack.</p>
</dd></dl>

</div>
<div class="section" id="custom-exceptions">
<h2>Custom exceptions<a class="headerlink" href="#custom-exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="SingularMatrixException__class">
<em class="property">type </em>class <tt class="descname">SingularMatrixException</tt><a class="headerlink" href="#SingularMatrixException__class" title="Permalink to this definition">¶</a></dt>
<dd><p>An extension of <tt class="docutils literal"><span class="pre">std::runtime_error</span></tt> which is meant to be thrown when
a singular matrix is unexpectedly encountered.</p>
<dl class="function">
<dt id="SingularMatrixException::SingularMatrixException__cCP">
 <tt class="descname">SingularMatrixException</tt><big>(</big>const char* <em>msg</em><em>=&quot;Matrix was singular&quot;</em><big>)</big><a class="headerlink" href="#SingularMatrixException::SingularMatrixException__cCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds an instance of the exception which allows one to optionally
specify the error message.</p>
</dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">throw</span> <span class="n">elem</span><span class="o">::</span><span class="n">SingularMatrixException</span><span class="p">();</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="NonHPDMatrixException__class">
<em class="property">type </em>class <tt class="descname">NonHPDMatrixException</tt><a class="headerlink" href="#NonHPDMatrixException__class" title="Permalink to this definition">¶</a></dt>
<dd><p>An extension of <tt class="docutils literal"><span class="pre">std::runtime_error</span></tt> which is meant to be thrown when
a non positive-definite Hermitian matrix is unexpectedly encountered
(e.g., during Cholesky factorization).</p>
<dl class="function">
<dt id="NonHPDMatrixException::NonHPDMatrixException__cCP">
 <tt class="descname">NonHPDMatrixException</tt><big>(</big>const char* <em>msg</em><em>=&quot;Matrix was not HPD&quot;</em><big>)</big><a class="headerlink" href="#NonHPDMatrixException::NonHPDMatrixException__cCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds an instance of the exception which allows one to optionally
specify the error message.</p>
</dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">throw</span> <span class="n">elem</span><span class="o">::</span><span class="n">NonHPDMatrixException</span><span class="p">();</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="NonHPSDMatrixException__class">
<em class="property">type </em>class <tt class="descname">NonHPSDMatrixException</tt><a class="headerlink" href="#NonHPSDMatrixException__class" title="Permalink to this definition">¶</a></dt>
<dd><p>An extension of <tt class="docutils literal"><span class="pre">std::runtime_error</span></tt> which is meant to be thrown when
a non positive semi-definite Hermitian matrix is unexpectedly encountered
(e.g., during computation of the square root of a Hermitian matrix).</p>
<dl class="function">
<dt id="NonHPSDMatrixException::NonHPSDMatrixException__cCP">
 <tt class="descname">NonHPSDMatrixException</tt><big>(</big>const char* <em>msg</em><em>=&quot;Matrix was not HPSD&quot;</em><big>)</big><a class="headerlink" href="#NonHPSDMatrixException::NonHPSDMatrixException__cCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds an instance of the exception which allows one to optionally
specify the error message.</p>
</dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">throw</span> <span class="n">elem</span><span class="o">::</span><span class="n">NonHPSDMatrixException</span><span class="p">();</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="complex-data">
<h2>Complex data<a class="headerlink" href="#complex-data" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="Complex:R:__struct">
<em class="property">type </em>struct <tt class="descname">Complex&lt;R&gt;</tt><a class="headerlink" href="#Complex:R:__struct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="Complex:R:::BaseType__R">
<em class="property">type </em>R <tt class="descname">BaseType</tt><a class="headerlink" href="#Complex:R:::BaseType__R" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="Complex:R:::real__R">
R <tt class="descname">real</tt><a class="headerlink" href="#Complex:R:::real__R" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of the complex number</p>
</dd></dl>

<dl class="member">
<dt id="Complex:R:::imag__R">
R <tt class="descname">imag</tt><a class="headerlink" href="#Complex:R:::imag__R" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of the complex number</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::Complex">
 <tt class="descname">Complex</tt><big>(</big><big>)</big><a class="headerlink" href="#Complex:R:::Complex" title="Permalink to this definition">¶</a></dt>
<dd><p>This default constructor is a no-op.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::Complex__R">
 <tt class="descname">Complex</tt><big>(</big>R <em>a</em><big>)</big><a class="headerlink" href="#Complex:R:::Complex__R" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction from a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::Complex__R.R">
 <tt class="descname">Complex</tt><big>(</big>R <em>a</em>, R <em>b</em><big>)</big><a class="headerlink" href="#Complex:R:::Complex__R.R" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction from a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::Complex__std::complex:R:CR">
 <tt class="descname">Complex</tt><big>(</big>const std::complex&lt;R&gt;&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::Complex__std::complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction from an <tt class="docutils literal"><span class="pre">std::complex&lt;R&gt;</span></tt> instance.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::assign-operator__RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator=</tt><big>(</big>const R&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::assign-operator__RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Assignment from a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::add-assign-operator__RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator+=</tt><big>(</big>const R&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::add-assign-operator__RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment with a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::sub-assign-operator__RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator-=</tt><big>(</big>const R&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::sub-assign-operator__RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement with a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::operator*=__RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator*=</tt><big>(</big>const R&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::operator*=__RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale with a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::div-assign-operator__RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator/=</tt><big>(</big>const R&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::div-assign-operator__RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide with a real value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::assign-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::assign-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Assignment from a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::add-assign-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator+=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::add-assign-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment with a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::sub-assign-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator-=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::sub-assign-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement with a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::operator*=__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator*=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::operator*=__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale with a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="Complex:R:::div-assign-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;&amp;</a> <tt class="descname">operator/=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#Complex:R:::div-assign-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide with a complex value.</p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="Base:F:__struct">
<em class="property">type </em>struct <tt class="descname">Base&lt;F&gt;</tt><a class="headerlink" href="#Base:F:__struct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="Base:F:::type">
<em class="property">type </em><tt class="descname">type</tt><a class="headerlink" href="#Base:F:::type" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying real datatype of the (potentially complex) datatype <cite>F</cite>.
For example, <tt class="docutils literal"><span class="pre">typename</span> <span class="pre">Base&lt;Complex&lt;double&gt;</span> <span class="pre">&gt;::type</span></tt> and
<tt class="docutils literal"><span class="pre">typename</span> <span class="pre">Base&lt;double&gt;::type</span></tt> are both equivalent to <tt class="docutils literal"><span class="pre">double</span></tt>.
This is often extremely useful in implementing routines which are
templated over real and complex datatypes but still make use of real
datatypes.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="add-operator__Complex:R:CR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator+</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#add-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) addition.</p>
</dd></dl>

<dl class="function">
<dt id="add-operator__Complex:R:CR.RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator+</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, const R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#add-operator__Complex:R:CR.RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) addition.</p>
</dd></dl>

<dl class="function">
<dt id="add-operator__RCR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator+</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#add-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) addition.</p>
</dd></dl>

<dl class="function">
<dt id="sub-operator__Complex:R:CR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator-</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#sub-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) subtraction.</p>
</dd></dl>

<dl class="function">
<dt id="sub-operator__Complex:R:CR.RR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator-</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#sub-operator__Complex:R:CR.RR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) subtraction.</p>
</dd></dl>

<dl class="function">
<dt id="sub-operator__RCR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator-</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#sub-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) subtraction.</p>
</dd></dl>

<dl class="function">
<dt id="mul-operator__Complex:R:CR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator*</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#mul-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="mul-operator__Complex:R:CR.RR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator*</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#mul-operator__Complex:R:CR.RR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="mul-operator__RCR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator*</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#mul-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) multiplication.</p>
</dd></dl>

<dl class="function">
<dt id="div-operator__Complex:R:CR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator/</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#div-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) division.</p>
</dd></dl>

<dl class="function">
<dt id="div-operator__Complex:R:CR.RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator/</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, const R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#div-operator__Complex:R:CR.RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) division.</p>
</dd></dl>

<dl class="function">
<dt id="div-operator__RCR.Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator/</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#div-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) division.</p>
</dd></dl>

<dl class="function">
<dt id="add-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator+</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#add-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>alpha</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="sub-operator__Complex:R:CR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">operator-</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#sub-operator__Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns negative <cite>alpha</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="eq-operator__Complex:R:CR.Complex:R:CR">
bool <tt class="descname">operator==</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#eq-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) equality check.</p>
</dd></dl>

<dl class="function">
<dt id="eq-operator__Complex:R:CR.RCR">
bool <tt class="descname">operator==</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, const R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#eq-operator__Complex:R:CR.RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) equality check.</p>
</dd></dl>

<dl class="function">
<dt id="eq-operator__RCR.Complex:R:CR">
bool <tt class="descname">operator==</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#eq-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) equality check.</p>
</dd></dl>

<dl class="function">
<dt id="neq-operator__Complex:R:CR.Complex:R:CR">
bool <tt class="descname">operator!=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#neq-operator__Complex:R:CR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,complex) inequality check.</p>
</dd></dl>

<dl class="function">
<dt id="neq-operator__Complex:R:CR.RCR">
bool <tt class="descname">operator!=</tt><big>(</big><a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>alpha</em>, const R&amp; <em>beta</em><big>)</big><a class="headerlink" href="#neq-operator__Complex:R:CR.RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>(complex,real) inequality check.</p>
</dd></dl>

<dl class="function">
<dt id="neq-operator__RCR.Complex:R:CR">
bool <tt class="descname">operator!=</tt><big>(</big>const R&amp; <em>alpha</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">const Complex&lt;R&gt;&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#neq-operator__RCR.Complex:R:CR" title="Permalink to this definition">¶</a></dt>
<dd><p>(real,complex) inequality check.</p>
</dd></dl>

<dl class="function">
<dt id="lshift-operator__osR.Complex:R:">
std::ostream&amp; <tt class="descname">operator&lt;&lt;</tt><big>(</big>std::ostream&amp; <em>os</em>, <a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <em>alpha</em><big>)</big><a class="headerlink" href="#lshift-operator__osR.Complex:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty prints <cite>alpha</cite> in the form <tt class="docutils literal"><span class="pre">a+bi</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="scomplex">
<em class="property">type </em><tt class="descname">scomplex</tt><a class="headerlink" href="#scomplex" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">typedef</span> <span class="pre">Complex&lt;float&gt;</span> <span class="pre">scomplex;</span></tt></p>
</dd></dl>

<dl class="type">
<dt id="dcomplex">
<em class="property">type </em><tt class="descname">dcomplex</tt><a class="headerlink" href="#dcomplex" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">typedef</span> <span class="pre">Complex&lt;double&gt;</span> <span class="pre">dcomplex;</span></tt></p>
</dd></dl>

</div>
<div class="section" id="scalar-manipulation">
<h2>Scalar manipulation<a class="headerlink" href="#scalar-manipulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Abs__FCR">
<a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type</a> <tt class="descname">Abs</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Abs__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the absolute value of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="FastAbs__FCR">
F <tt class="descname">FastAbs</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#FastAbs__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cheaper norm of the real or complex <span class="math">\(\alpha\)</span>:</p>
<div class="math">
\[|\alpha|_{\mbox{fast}} = |\mathcal{R}(\alpha)| + |\mathcal{I}(\alpha)|\]</div>
</dd></dl>

<dl class="function">
<dt id="RealPart__FCR">
F <tt class="descname">RealPart</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#RealPart__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="ImagPart__FCR">
F <tt class="descname">ImagPart</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#ImagPart__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="SetRealPart__FR.typename-Base:F:::typeR">
void <tt class="descname">SetRealPart</tt><big>(</big>F&amp; <em>alpha</em>, <a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#SetRealPart__FR.typename-Base:F:::typeR" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the real part of the real or complex variable <span class="math">\(\alpha\)</span> to
<span class="math">\(\beta\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="SetImagPart__FR.typename-Base:F:::typeR">
void <tt class="descname">SetImagPart</tt><big>(</big>F&amp; <em>alpha</em>, <a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#SetImagPart__FR.typename-Base:F:::typeR" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the imaginary part of the complex variable <span class="math">\(\alpha\)</span> to
<span class="math">\(\beta\)</span>. If <span class="math">\(\alpha\)</span> has a real type, an error is thrown.</p>
</dd></dl>

<dl class="function">
<dt id="UpdateRealPart__FR.typename-Base:F:::typeR">
void <tt class="descname">UpdateRealPart</tt><big>(</big>F&amp; <em>alpha</em>, <a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#UpdateRealPart__FR.typename-Base:F:::typeR" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the real part of the real or complex variable <span class="math">\(\alpha\)</span> to
<span class="math">\(\beta\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="UpdateImagPart__FR.typename-Base:F:::typeR">
void <tt class="descname">UpdateImagPart</tt><big>(</big>F&amp; <em>alpha</em>, <a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type&amp;</a> <em>beta</em><big>)</big><a class="headerlink" href="#UpdateImagPart__FR.typename-Base:F:::typeR" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the imaginary part of the complex variable <span class="math">\(\alpha\)</span> to
<span class="math">\(\beta\)</span>. If <span class="math">\(\alpha\)</span> has a real type, an error is thrown.</p>
</dd></dl>

<dl class="function">
<dt id="Conj__FCR">
F <tt class="descname">Conj</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Conj__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Sqrt__FCR">
F <tt class="descname">Sqrt</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Sqrt__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the square root or the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Cos__FCR">
F <tt class="descname">Cos</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Cos__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cosine of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Sin__FCR">
F <tt class="descname">Sin</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Sin__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sine of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Tan__FCR">
F <tt class="descname">Tan</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Tan__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tangent of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Cosh__FCR">
F <tt class="descname">Cosh</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Cosh__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic cosine of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Sinh__FCR">
F <tt class="descname">Sinh</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Sinh__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic sine of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Arg__FCR">
<a class="reference internal" href="#Base:F:::type" title="Base&lt;F&gt;::type">typename Base&lt;F&gt;::type</a> <tt class="descname">Arg</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Arg__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the argument of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Polar__RCR.RCR">
<a class="reference internal" href="#Complex:R:__struct" title="Complex&lt;R&gt;">Complex&lt;R&gt;</a> <tt class="descname">Polar</tt><big>(</big>const R&amp; <em>r</em>, const R&amp; <em>theta</em><em>=0 </em><big>)</big><a class="headerlink" href="#Polar__RCR.RCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex variable constructed from the polar coordinates
<span class="math">\((r,\theta)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Exp__FCR">
F <tt class="descname">Exp</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Exp__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the exponential of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Pow__FCR.FCR">
F <tt class="descname">Pow</tt><big>(</big>const F&amp; <em>alpha</em>, const F&amp; <em>beta</em><big>)</big><a class="headerlink" href="#Pow__FCR.FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math">\(\alpha^\beta\)</span> for real or complex <span class="math">\(\alpha\)</span> and
<span class="math">\(\beta\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="Log__FCR">
F <tt class="descname">Log</tt><big>(</big>const F&amp; <em>alpha</em><big>)</big><a class="headerlink" href="#Log__FCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the logarithm of the real or complex variable <span class="math">\(\alpha\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="other-typedefs-and-enums">
<h2>Other typedefs and enums<a class="headerlink" href="#other-typedefs-and-enums" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="byte">
<em class="property">type </em><tt class="descname">byte</tt><a class="headerlink" href="#byte" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">typedef</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">byte;</span></tt></p>
</dd></dl>

<dl class="type">
<dt id="Conjugation__enum">
<em class="property">type </em>enum <tt class="descname">Conjugation</tt><a class="headerlink" href="#Conjugation__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum which can be set to either <tt class="docutils literal"><span class="pre">CONJUGATED</span></tt> or <tt class="docutils literal"><span class="pre">UNCONJUGATED</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="Distribution__enum">
<em class="property">type </em>enum <tt class="descname">Distribution</tt><a class="headerlink" href="#Distribution__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying the distribution of a row or column of a distributed
matrix:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">MC</span></tt>: Column of a standard matrix distribution</li>
<li><tt class="docutils literal"><span class="pre">MD</span></tt>: Diagonal of a standard matrix distribution</li>
<li><tt class="docutils literal"><span class="pre">MR</span></tt>: Row of a standard matrix distribution</li>
<li><tt class="docutils literal"><span class="pre">VC</span></tt>: Column-major vector distribution</li>
<li><tt class="docutils literal"><span class="pre">VR</span></tt>: Row-major vector distribution</li>
<li><tt class="docutils literal"><span class="pre">STAR</span></tt>: Redundantly stored on every process</li>
<li><tt class="docutils literal"><span class="pre">CIRC</span></tt>: Stored on a single process</li>
</ul>
</dd></dl>

<dl class="type">
<dt id="ForwardOrBackward__enum">
<em class="property">type </em>enum <tt class="descname">ForwardOrBackward</tt><a class="headerlink" href="#ForwardOrBackward__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying <tt class="docutils literal"><span class="pre">FORWARD</span></tt> or <tt class="docutils literal"><span class="pre">BACKWARD</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="GridOrder__enum">
<em class="property">type </em>enum <tt class="descname">GridOrder</tt><a class="headerlink" href="#GridOrder__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying either a <tt class="docutils literal"><span class="pre">ROW_MAJOR</span></tt> or <tt class="docutils literal"><span class="pre">COLUMN_MAJOR</span></tt> ordering;
it is used to tune one of the algorithms in <a class="reference internal" href="../lapack-like/condensed.html#HermitianTridiag__UpperOrLower.Matrix:F:R" title="HermitianTridiag"><tt class="xref cpp cpp-func docutils literal"><span class="pre">HermitianTridiag()</span></tt></a>
which requires building a smaller square process grid from a rectangular
process grid, as the ordering of the processes can greatly impact
performance. See <a class="reference internal" href="../lapack-like/tuning.html#SetHermitianTridiagGridOrder__GridOrder" title="SetHermitianTridiagGridOrder"><tt class="xref cpp cpp-func docutils literal"><span class="pre">SetHermitianTridiagGridOrder()</span></tt></a>.</p>
</dd></dl>

<dl class="type">
<dt id="LeftOrRight__enum">
<em class="property">type </em>enum <tt class="descname">LeftOrRight</tt><a class="headerlink" href="#LeftOrRight__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying <tt class="docutils literal"><span class="pre">LEFT</span></tt> or <tt class="docutils literal"><span class="pre">RIGHT</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="SortType__enum">
<em class="property">type </em>enum <tt class="descname">SortType</tt><a class="headerlink" href="#SortType__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying a sorting strategy:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">UNSORTED</span></tt>: do not sort</li>
<li><tt class="docutils literal"><span class="pre">DESCENDING</span></tt>: smallest values first</li>
<li><tt class="docutils literal"><span class="pre">ASCENDING</span></tt>: largest values first</li>
</ul>
</dd></dl>

<dl class="type">
<dt id="NormType__enum">
<em class="property">type </em>enum <tt class="descname">NormType</tt><a class="headerlink" href="#NormType__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum that can be set to either</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">ONE_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_1 = \max_{\|x\|_1=1} \|Ax\|_1
        = \max_j \sum_{i=0}^{m-1} |\alpha_{i,j}|\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">INFINITY_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_{\infty} = \max_{\|x\|_{\infty}=1} \|Ax\|_{\infty}
               = \max_i \sum_{j=0}^{n-1} |\alpha_{i,j}|\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">MAX_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_{\mbox{max}} = \max_{i,j} |\alpha_{i,j}|\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">NUCLEAR_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_* = \sum_{i=0}^{\min(m,n)} \sigma_i(A)\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">FROBENIUS_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_F = \sqrt{\sum_{i=0}^{m-1} \sum_{j=0}^{n-1} |\alpha_{i,j}|^2}
        = \sum_{i=0}^{\min(m,n)} \sigma_i(A)^2\]</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">TWO_NORM</span></tt>:</p>
<div class="math">
\[\|A\|_2 = \max_i \sigma_i(A)\]</div>
</li>
</ul>
</dd></dl>

<dl class="type">
<dt id="Orientation__enum">
<em class="property">type </em>enum <tt class="descname">Orientation</tt><a class="headerlink" href="#Orientation__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying whether a matrix, say <span class="math">\(A\)</span>, should be implicitly
treated as <span class="math">\(A\)</span> (<tt class="docutils literal"><span class="pre">NORMAL</span></tt>), <span class="math">\(A^H\)</span> (<tt class="docutils literal"><span class="pre">ADJOINT</span></tt>), or <span class="math">\(A^T\)</span>
(<tt class="docutils literal"><span class="pre">TRANSPOSE</span></tt>).</p>
</dd></dl>

<dl class="type">
<dt id="UnitOrNonUnit__enum">
<em class="property">type </em>enum <tt class="descname">UnitOrNonUnit</tt><a class="headerlink" href="#UnitOrNonUnit__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying either <tt class="docutils literal"><span class="pre">UNIT</span></tt> or <tt class="docutils literal"><span class="pre">NON_UNIT</span></tt>; typically used for
stating whether or not a triangular matrix&#8217;s diagonal is explicitly stored
(<tt class="docutils literal"><span class="pre">NON_UNIT</span></tt>) or is implicitly unit-diagonal (<tt class="docutils literal"><span class="pre">UNIT</span></tt>).</p>
</dd></dl>

<dl class="type">
<dt id="UpperOrLower__enum">
<em class="property">type </em>enum <tt class="descname">UpperOrLower</tt><a class="headerlink" href="#UpperOrLower__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying <tt class="docutils literal"><span class="pre">LOWER</span></tt> or <tt class="docutils literal"><span class="pre">UPPER</span></tt> (triangular).</p>
</dd></dl>

<dl class="type">
<dt id="VerticalOrHorizontal__enum">
<em class="property">type </em>enum <tt class="descname">VerticalOrHorizontal</tt><a class="headerlink" href="#VerticalOrHorizontal__enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enum for specifying <tt class="docutils literal"><span class="pre">VERTICAL</span></tt> or <tt class="docutils literal"><span class="pre">HORIZONTAL</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="indexing-utilities">
<h2>Indexing utilities<a class="headerlink" href="#indexing-utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Shift__Int.Int.Int">
Int <tt class="descname">Shift</tt><big>(</big>Int <em>rank</em>, Int <em>firstRank</em>, Int <em>numProcs</em><big>)</big><a class="headerlink" href="#Shift__Int.Int.Int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a element-wise cyclic distribution over <cite>numProcs</cite> processes,
where the first entry is owned by the process with rank <cite>firstRank</cite>,
this routine returns the first entry owned by the process with rank
<cite>rank</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="LocalLength__Int.Int.Int">
Int <tt class="descname">LocalLength</tt><big>(</big>Int <em>n</em>, Int <em>shift</em>, Int <em>numProcs</em><big>)</big><a class="headerlink" href="#LocalLength__Int.Int.Int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector with <span class="math">\(n\)</span> entries distributed over <cite>numProcs</cite>
processes with shift as defined above, this routine returns the number of
entries of the vector which are owned by this process.</p>
</dd></dl>

<dl class="function">
<dt id="LocalLength__Int.Int.Int.Int">
Int <tt class="descname">LocalLength</tt><big>(</big>Int <em>n</em>, Int <em>rank</em>, Int <em>firstRank</em>, Int <em>numProcs</em><big>)</big><a class="headerlink" href="#LocalLength__Int.Int.Int.Int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector with <span class="math">\(n\)</span> entries distributed over <cite>numProcs</cite>
processes, with the first entry owned by process <cite>firstRank</cite>, this routine
returns the number of entries locally owned by the process with rank
<cite>rank</cite>.</p>
</dd></dl>

</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="imports/flame.html">libFLAME</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="matrix.html">The Matrix class</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2009-2013, Jack Poulson.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>